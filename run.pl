


% assume that the input is fixed and generated by generator.py, stored in 
% board.pl



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% this part is to process the input read from board.pl,
% we do not use this part for solving
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- dynamic mine/2.


% Val = the number in selected cell
cell(R, C, Val) :-
	(	mine(R, C),
		Val = 'boom!',
		!
	;	not(mine(R, C)),
		R >= 0, R < 16,
		C >= 0, C < 30,
		% neighbors
		Rm is R-1, Rp is R+1,
		Cm is C-1, Cp is C+1,
		Around = [
			mine(Rm, Cm), mine(Rm, C), mine(Rm, Cp),
			mine(R, Cm), mine(R, Cp),
			mine(Rp, Cm), mine(Rp, C), mine(Rp, Cp)
		],
		% count the number of mines
		count_true(Around, Val)
	).

% count the number of true predicates in the input list
count_true([], 0).
count_true([Head|Tail], RetVal) :-
	(	Head,
		count_true(Tail, RecurRetVal),
		RetVal is RecurRetVal + 1,
		!
	;	not(Head),
		count_true(Tail, RecurRetVal),
		RetVal is RecurRetVal,
		!
	).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% this part is to apply the play rules
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- dynamic known/3.


% truly reveal the cell
reveal(R, C) :-
	(	not((
			R >= 0, R < 16,
			C >= 0, C < 30
		)),
		!
	;	known(R, C, _),
		!
	;	mine(R, C),
		format('\nboom!. you touch the bomb at (~w, ~w).\n', [R, C]),
		print_failed
	;	not(mine(R, C)),
		not(known(R, C, _)),
		cell(R, C, Val),
		(
			% known(R, C, Val);
			assert(known(R, C, Val))
		),
		(
			Val > 0
			;
			Val = 0,
			Rm is R-1, Rp is R+1,
			Cm is C-1, Cp is C+1,
			reveal(Rm, Cm), reveal(Rm, C), reveal(Rm, Cp),
			reveal(R, Cm), reveal(R, Cp),
			reveal(Rp, Cm), reveal(Rp, C), reveal(Rp, Cp)
		),
		!
	).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% this part is for solving
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- dynamic flag/2.

% A cell has 4 states:
% 1. unknown (default)
% 2. known (known(R, C, _))
% 3. flagged (flag(R, C))
% 4. safe -> reveal.


% apply flag_k to every cells
% rule: mines = unknown => all unknown cells are mines, flag them all
flag_by_pattern(R, C) :-
	(	% neighbors
		Rm is R-1, Rp is R+1,
		Cm is C-1, Cp is C+1,
		Around = [
			known(Rm, Cm, _), known(Rm, C, _), known(Rm, Cp, _),
			known(R, Cm, _), known(R, Cp, _),
			known(Rp, Cm, _), known(Rp, C, _), known(Rp, Cp, _)
		],
		% compare the number of unknown cells with the number of mines
		count_true(Around, NumSafe),
		known(R, C, NumMine),
		NumMine > 0,
		(	% 4 corner
			(R =:= 0; R =:= 15), (C =:= 0; C =:= 29), SumCell is 3
		;	% top and bottom border
			(R =:= 0; R =:= 15), C =\= 0, C =\= 29, SumCell is 5
		;	% left and right border
			(C =:= 0; C =:= 29), R =\= 0, R =\= 15, SumCell is 5
		;	% normal cells
			SumCell is 8
		),
		SumCell - NumSafe =:= NumMine,
		% filter the known cells, flag the unknowns
		include(not, Around, Unknown),
		maplist(flag_k, Unknown)
	;	% always return true
		true
	).

% flag the selected cell as mine
do_flag(R, C) :-
	(	% ignore if it is already flagged
		flag(R, C),
		!
	;	R >= 0, R < 16, C >= 0, C < 30,
		not(flag(R, C)),
		assert(flag(R, C))
	).

% flag the selected cell, but with another syntax
flag_k(known(R, C, _)) :-
	(	do_flag(R, C)
	;	true
	).

% apply reveal to every known safe cells
% rule: mines = flagged => all unknown cells are safe, reveal them all
reveal_by_pattern(R, C) :-
	(	% neighbors
		Rm is R-1, Rp is R+1,
		Cm is C-1, Cp is C+1,
		Around = [
			flag(Rm, Cm), flag(Rm, C), flag(Rm, Cp),
			flag(R, Cm), flag(R, Cp),
			flag(Rp, Cm), flag(Rp, C), flag(Rp, Cp)
		],
		count_true(Around, NumFlag),
		known(R, C, NumMine),
		NumFlag =:= NumMine,
		% filter the flagged cells, reveal the unknowns
		include(not, Around, Unknown),
		maplist(reveal_f, Unknown)
	;	% always return true
		true
	).

% reveal the selected cell, but with another syntax
reveal_f(flag(R, C)):-
	(	% the reveal procedure is already checked if the cell is known
		reveal(R, C),
		!
	;	true
	).

match_pattern :-
	(	% while known cells and mines are still not fit the board
		findall(1, known(_, _, _), Temp),
		length(Temp, Length),
		Length < 381, % = 16 * 30 - 99
		% keep flagging mines
		findall(1, flag(_, _), FlagListBefore),
		length(FlagListBefore, FlagCountBefore),
		forall(known(R, C, _), flag_by_pattern(R, C)),
		findall(1, flag(_, _), FlagListAfter),
		length(FlagListAfter, FlagCountAfter),
		% and revealing cells
		findall(1, known(_, _, _), KnownListBefore),
		length(KnownListBefore, KnownCountBefore),
		forall(known(R, C, _), reveal_by_pattern(R, C)),
		findall(1, known(_, _, _), KnownListAfter),
		length(KnownListAfter, KnownCountAfter),
		(	% until break condition
			FlagCountAfter =:= FlagCountBefore,
			KnownCountAfter =:= KnownCountBefore,
			CellLeft is 381 - KnownCountAfter,
			format('There are ~w/381 unrevealed cell(s), flagged ~w/99.\n',
				[CellLeft, FlagCountAfter]),
			!
		;	% recursive call until reach break condition
			match_pattern
		),
		!
	;	print_success
	).


% print the board for checking
print_board :-
	writeln('___________________________________________________________________________________________\n'),
	writeln('   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29'),
	writeln('   ________________________________________________________________________________________'),
	print_lines(0),
	writeln('___________________________________________________________________________________________\n').


print_lines(R) :-
	(	R < 16,
		format('~|~w~2||', [R]),
		print_cells(R, 0),
		R1 is R + 1,
		write('\n'),
		print_lines(R1),
		!
	;	R >= 16,
		true
	).

print_cells(R, C) :-
	(	C < 30,
		(known(R, C, Cell); flag(R, C), Cell = '*'; Cell = '.'),
		format('~w  ', [Cell]),
		C1 is C + 1,
		print_cells(R, C1),
		!
	;	C >= 30,
		true
	).


% end game
print_failed :-
	forall(mine(R, C), assert(flag(R, C))),
	print_board,
	halt.

print_success :-
	print_board,
	writeln('success!'),
	halt.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% this part is the interface
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
choose(R, C) :-
	reveal(R, C),
	print_board.

mark(R, C) :-
	do_flag(R, C),
	print_board.

solve :-
	match_pattern,
	print_board.
